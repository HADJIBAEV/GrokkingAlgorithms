# Solving the tasks of the entrance test for an internship using the Golang language.

--- 
## Task № 1 (Наклейки)
> Для отслеживания посылок компания **NOZO** использует наклейки с надписями. Иногда надпись (или её часть) на наклейке нужно исправить, и тогда поверх старой наклейки лепят новую.
<br> На очередной посылке появилось слишком много наклеек и теперь невозможно прочитать наклеенную надпись целиком.
<br> Помогите это сделать по истории этих наклеек.
<br><br> **Формат входных данных:**
> Первая строка **s** представляет собой содержимое изначальной наклейки. Гарантируется, что её длина не превышает **1000** символов.
<br> Во второй строке записано целое число **n(1≤n≤1000)**, обозначающее количество наклеенных поверх наклеек.
<br> Далее идёт **n** строк, каждая из которых описывает очередную наклейку в порядке её применения: от самой старой к самой новой. Каждое описание содержит два числа **start(i)** и **end(i)**  (**1≤start≤end≤|s|**, где **|s|** обозначает длину
> строки **s**) и через пробел строку **r(i)**, которая была записана поверх символов между **start(i)** и **end(i)**. Гарантируется, что длина строки **r(i)** точно равна **end−start+1**. Эта запись обозначает, что поверх всех символов, начиная
> с символа под номером **start** и заканчивая символом под номером **end** , была наклеена строка **r(i)**.
<br> Гарантируется, что все строки состоят только из строчных латинских букв.
<br><br> **Формат выходных данных:**
<br> Выведите итоговую строку, которая видна после применения всех наклеек.

### Examples data:
| № |        Ввод         |        Вывод        | № |        Ввод         |        Вывод         |
|:-:|:-------------------:|:-------------------:|:-:|:-------------------:|:--------------------:|
| 1 | somesuperlongstring | lamdsupertinystring | 2 | somesuperlongstring | lamedupertinystring  |
|   |          3          |                     |   |          4          |                      |
|   |       1 2 la        |                     |   |       1 2 la        |                      |
|   |        4 4 d        |                     |   |        4 4 d        |                      |
|   |     10 13 tiny      |                     |   |     10 13 tiny      |                      |
|   |                     |                     |   |       4 5 ed        |                      |

--- 

## Task № 2 (Битва за кондиционер)
>В офисе стоит кондиционер, на котором можно установить температуру от **15** до **30** градусов.
<br> В офис по очереди приходят n сотрудников. *i* -й из них желает температуру не больше или не меньше *ai*.
<br> После прихода каждого сотрудника определите, можно ли выставить температуру, которая удовлетворит всех в офисе.
<br><br> **Формат входных данных:**
> Каждый тест состоит из нескольких наборов входных данных. Первая строка содержит целое число **t (1≤t≤10^3)** — количество наборов входных данных. Далее следует описание наборов входных данных.
<br> Первая строка каждого набора содержит целое число **n (1≤n≤10^3)** — количество сотрудников.
<br> **i** -я из следующих **n** строк каждого набора входных данных содержит требование к температуре от **i** -го сотрудника: либо **≥ai** , либо **≤ai** **(15≤ai≤30, ai— целое число)**. 
> Требование **≥ai** означает, что **i** -й сотрудник желает температуру не ниже **ai**; требование **≤ai** означает, что **i**-й сотрудник желает температуру не выше **ai**.
<br> Гарантируется, что сумма **n** по всем наборам входных данных не превосходит 10^3.
<br><br> **Формат выходных данных:**
<br> Для каждого набора входных данных выведите n строк, i-я из которых содержит температуру, удовлетворяющую всех сотрудников с номерами от 1 до i включительно. Если такой температуры не существует, выведите −1 . После вывода ответа на очередной набор входных данных выводите пустую строку.
<br> Если ответов несколько, выведите любой.
### Examples data:
| №  |   Input    | Output | 
|:--:|:----------:|:------:| 
| 1  |     4      |        |
| 2  |     1      |        |
| 3  | `  >= 30 ` |   30   |
| 4  |     6      |        |
| 5  | `  >= 18 ` |   29   |
| 6  | `  <= 23 ` |   19   |
| 7  | `  >= 20 ` |   22   |
| 8  | `  <= 27 ` |   21   |
| 9  | `  <= 21 ` |   20   |
| 10 | `  >= 28 ` |   -1   |
| 11 |     3      |        |
| 12 | `  <= 25 ` |   23   |
| 13 | `  >= 20 ` |   22   |
| 14 | `  >= 25 ` |   25   |
| 15 |     3      |        |
| 16 | `  <= 15 ` |   15   |
| 17 | `  >= 30 ` |   -1   |
| 18 | `  <= 24 ` |   -1   |

>**Примечание** 
<br> **Пояснение к первому примеру:**
<br>  1) добавляется требование **≥30**, диапазон возможных температур — **[30, 30]**, поэтому единственный возможный ответ — **30** градусов.
<br> **Пояснение ко второму примеру:**
<br> 1) добавляется требование **≥18**, диапазон возможных температур — **[18, 30]**, поэтому в качестве примера взяли **29** градусов;
<br> 2) добавляется требование **≤23**, диапазон возможных температур — **[18, 23]**, поэтому в качестве примера взяли **19** градусов;
<br> 3) добавляется требование **≥20**, диапазон возможных температур — **[20, 23]**, поэтому в качестве примера взяли **22** градуса;
<br> 4) добавляется требование **≤27**, диапазон возможных температур — **[20, 23]**, поэтому в качестве примера взяли **21** градус;
<br> 5) добавляется требование **≤21**, диапазон возможных температур — **[20, 21]**, поэтому в качестве примера взяли **20** градусов;
<br> 6)добавляется требование **≥28**, диапазон возможных температур — **[28, 21]**, поэтому ответа нет и нужно вывести **-1**.
<br> **Пояснение к третьему примеру:**
<br> 1) добавляется требование **≤25**, диапазон возможных температур — **[15, 25]**, поэтому в качестве примера взяли **23** градуса;
<br> 2) добавляется требование **≥20**, диапазон возможных температур — **[20, 25]**, поэтому в качестве примера взяли **22** градуса;
<br> 3)добавляется требование **≥25**, диапазон возможных температур — **[25, 25]**, поэтому в качестве примера можно взять только **25** градусов.
<br> **Пояснение к четвертому примеру:**
<br> 1)добавляется требование **≤15**, диапазон возможных температур — **[15, 15]**, поэтому в качестве примера можно взять только **15** градусов; 
<br> 2) добавляется требование **≥30**, диапазон возможных температур — **[30, 15]**, поэтому ответа нет и нужно вывести **-1**;
<br> 3) добавляется требование **≤24**, диапазон возможных температур — **[30, 15]**, поэтому ответа нет и нужно вывести **-1**.
---

## Task № 3 (ASCII-горы)
>Назовём рельефом гор **2D**-изображение из **n** строк **и m** столбцов, состоящее только из символов **'X', '.' (точка), '/' (прямой слеш) и '\' (обратный слеш)**. Изображение составлено по следующим формальным правилам:
<br>   - либо непосредственно слева снизу от символа **'/'** находится такой же символ, либо непосредственно слева от символа **'/'** находится символ **'\'**, либо символ **'/'** находится на нижней строке;
<br>   - либо непосредственно справа сверху от символа **'/'** находится такой же символ, либо непосредственно справа от символа **'/'** находится символ **'\'**;
<br>   - либо непосредственно слева сверху от символа **'\'** находится такой же символ, либо непосредственно слева от символа **'\'** находится символ **'/'**;
<br>   - либо непосредственно справа снизу от символа **'\'** находится такой же символ, либо непосредственно справа от символа **'\'** находится символ **'/'**, либо символ **'\'** находится на нижней строке;
<br>   - каждый столбец содержит не более одного из символов **'/'** и **'\'**;
<br>   - в каждом столбце все символы ниже **'/' и '\'** равны **'X'**;
<br>   - все остальные символы равны **'.'**.
<br> Все символы, кроме **'.'**, являются частью горы.
<br> В каждом рельефе гор есть хотя бы один символ, не равный **'.'**.
<br> Дано **k** рельефов по их близости к наблюдателю: от ближних к дальним. Выведите рельеф, видный наблюдателю. Если в некотором рельефе символ в **x**-й строке и **y** -м столбце является частью горы, то во всех более дальних 
> от наблюдателя рельефах гор символы на этой позиции не видны наблюдателю.
<br><br> **Формат входных данных:**
<br> Каждый тест состоит из нескольких наборов входных данных. Первая строка содержит целое число **t(1≤t≤20)** — количество наборов входных данных. Далее следует описание наборов входных данных.
<br> Первая строка каждого набора содержит три целых числа **k, n и m(1≤k,n≤20, 2≤m≤20)** — количество рельефов, высоту и ширину **ASCII**-арта.
<br> Далее следуют описания **k** рельефов гор.
<br> Описание рельефа гор состоит из n строк, по m символов в каждой — сам **ASCII**-арт.
<br> Описания рельефов разделены пустой строкой.
<br><br> **Формат выходных данных:**
<br> Для каждого набора входных данных выведите в **n** строках рельеф гор, видный наблюдателю. После ответа на каждый набор входных данных выведите пустую строку.

### Examples data:
| № |         Input         |        Output         | 
|:-:|:---------------------:|:---------------------:| 
| 1 |           3           |                       |
| 2 |        2 6 18         |                       |
| 3 | ` ..................` | `........../\...... ` |
| 4 | `..................`  | `........./XX\.....`  |
| 5 | `.../\.............`  | `.../\.../XXXX\.... ` |
| 6 | `../XX\/\../\......`  | `../XX\/\XX/\XX\...`  |
| 7 | `./XXXXXX\/XX\.....`  | `./XXXXXX\/XX\XX\..`  |
| 8 | ` /XXXXXXXXXXXX\....` | `/XXXXXXXXXXXX\XX\.`  |
| 9 |                       |                       |
| 9 | `........../\......`  |                       |
| 9 | `........./XX\.....`  |         `..`          |
| 9 | `......../XXXX\....`  |         `/\`          |
| 9 | `.../\../XXXXXX\...`  |                       |
| 9 | `../XX\/XXXXXXXX\..`  |                       |
| 9 | `./XXXXXXXXXXXXXX\.`  |        `.....`        |
| 9 |         1 2 2         |        `.....`        |
| 9 |         `..`          |          ``           |
| 9 |         `/\`          |        `./\\.`        |
| 9 |         3 4 5         |        `//\\\`        |
| 9 |        `.....`        |                       |
| 9 |        `.....`        |                       |
| 9 |        `.....`        |                       |
| 9 |        `./\..`        |                       |
| 9 |                       |                       |
| 9 |        `.....`        |                       |
| 9 |        `.....`        |                       |
| 9 |        `./\..`        |                       |
| 9 |        `/XX\.`        |                       |
| 9 |                       |                       |
| 9 |        `.....`        |                       |
| 9 |        `.....`        |                       |
| 9 |        `../\.`        |                       |
| 9 |        `./XX\`        |                       |

## Task № 4 (Карточки)
>Среди ваших **n** друзей стало популярно коллекционирование редчайших карточек. Производитель выпустил **m** различных видов карточек, пронумерованных от **1 до m**. Эти карточки настолько редкие, что их продает только один человек. Известно, что у него осталось всего **m** карточек, по одной каждого вида. 
<br> Вам известно, что у **i** -го из ваших друзей есть все карточки с номерами от **1 до ai** включительно. Вы хотите сделать подарок всем своим друзьям, подарив **i**-му из них карточку **bi** , которой у него еще нет, то есть такую, что **bi>ai**.
<br><br> **Формат входных данных:**
<br> Первая строка содержит два целых числа **n и m(1≤n,m≤105)** — количество друзей и количество карточек.
<br> Вторая строка содержит **n** целых чисел **ai(1≤ai≤m)**.
<br> Решения, работающие правильно при **n,m≤100**, получат **10** баллов.
<br><br> **Формат выходных данных:**
<br>Выведите массив **bi** или **−1**, если ответа не существует. Если ответов несколько, выведите любой.

### Examples data:
| №  |   Input   |  Output   | 
|:--:|:---------:|:---------:| 
| 1  |    5 7    | 5 4 3 7 6 |
| 2  | 3 3 2 6 5 |           |
| 3  |    4 4    |    -1     |
| 4  |  2 1 2 2  |           |
| 5  |    5 6    | 4 2 3 5 6 |
| 6  | 3 1 2 3 5 |           |

>**Примечание**
<br> **Пояснение к первому примеру:**
<br> У нас есть **5** друзей и **7** различных карточек.
<br>  1) Мы дарим 1 другу — 5 карточку, так как ее у него еще нет. Пока неподаренными остались карточки [1, 2, 3, 4, 6, 7].
<br>  2) Мы дарим 2 другу — 4 карточку, так как ее у него еще нет. Пока неподаренными остались карточки [1, 2, 3, 6, 7].
<br>  3) Мы дарим 3 другу — 3 карточку, так как ее у него еще нет. Пока неподаренными остались карточки [1, 2, 6, 7].
<br>  4) Мы дарим 4 другу — 7 карточку, так как ее у него еще нет. Пока неподаренными остались карточки [1, 2, 6].
<br>  5) Мы дарим 5 другу — 6 карточку, так как ее у него еще нет. Пока неподаренными остались карточки [1, 2].
<br> Также возможны и другие варианты раздачи карточек.
<br> Во втором тесте никак нельзя выдать карточки правильно, поэтому и ответ — **-1**.

## Task № 5 (JSON категории)
>На маркетплейсе у каждого товара есть категория. При этом, у некоторых категорий есть дочерние категории. Для удобной навигации по маркетплейсу покупатели могут пользоваться деревом категорий.
<br> Ваша задача — построить дерево категорий. Дана информация об отношениях родительских и дочерних категорий в виде **JSON**-массива. Каждый элемент массива является словарем, с полями name (название категории), **id** (числовой идентификатор категории) и **parent** (числовой идентификатор родительской категории). Известно, что корневая категория имеет нулевой идентификатор и не имеет идентификатора родительской категории.
<br>По данной информации постройте дерево категорий в виде JSON-словаря. Словарь для каждой категории должен иметь поля name, **id** и массив **next**, состоящий из таких же словарей для дочерних категорий.
<br><br> **Формат входных данных:**
<br> Каждый тест состоит из нескольких наборов входных данных. Первая строка содержит целое число **t(1≤t≤100)** — количество наборов входных данных. Далее следует описание наборов входных данных.
<br> Первая строка каждого набора входных данных содержит целое число **n(1≤n≤1000)** — количество строк с описанием **JSON**-массива категорий.
<br> Следующие **n** строк содержат описание **JSON**-массива категорий. Все числовые идентификаторы категорий являются целыми числами и удовлетворяют условию **0≤id≤109**. Все имена категорий непустые, состоят из строчных латинских букв и имеют длину не больше **20**. В описании могут быть символы пробела и табуляции.
<br> Гарантируется, что каждый набор входных данных содержит корневую категорию и не более **400** категорий.
<br> Гарантируется, что размер входных данных не превосходит **10Мб**.
<br><br> **Формат выходных данных:**
<br> Выведите **JSON**-массив из **t** элементов. **i**-й элемент массива является словарем с описанием дерева категорий для **i** -го набора входных данных. При проверке ответа пробелы, табы и переносы строки не учитываются(кроме таковых в json полях). Порядок полей в словаре и порядок дочерних категорий в массиве next не учитывается. Если у категории нет дочерних категорий, ключ next может отсутствовать, или соответствовать пустому массиву.

### Examples data:
| №  |                        Input                         |                                                     Output                                                     | 
|:--:|:----------------------------------------------------:|:--------------------------------------------------------------------------------------------------------------:| 
| 1  |                          2                           |                                                       1                                                        |
| 2  |                          21                          |                                                       9                                                        |
| 3  |                         `[`                          |                                                      `[`                                                       |
| 4  |                        `   {`                        |                                       `{"name": "everything", "id": 0},`                                       |
| 5  |                    `     "id":0,`                    |                                 ` {"name": "clothes", "id": 1, "parent": 0},`                                  |
| 6  |                 `     "name":"all"`                  |                                `{"name": "electronics", "id": 2, "parent": 0},`                                |
| 7  |                       `   },`                        |                                 `{"name": "computers", "id": 4, "parent": 2},`                                 |
| 8  |                        `   {`                        |                                    `{"name": "aio", "id": 3, "parent": 4},`                                    |
| 9  |                   `       "id":1,`                   |                                    `{"name": "tv", "id": 5, "parent": 2},`                                     |
| 10 |              `      "name":"clothes",`               |                                   ` {"name": "house", "id": 6, "parent": 0}`                                   |
| 11 |                  `      "parent":0`                  |                                                      `]`                                                       |
| 12 |                       `   },`                        |                                                                                                                |
| 13 |                        `   {`                        |                                                                                                                |
| 14 |                   `       "id":2,`                   |                                                                                                                |
| 15 |               `       "name":"shoes",`               |                                                                                                                |
| 16 |                  `      "parent":0`                  |                                                      `[`                                                       |
| 17 |                       `   },`                        | `{"id":0,"name":"everything","next":[{"id":1,"name":"clothes","next":[]},{"id":2,"name":"electronics","next":` |
| 18 |                        `   {`                        |   `[{"id":4,"name":"computers","next":[{"id":3,"name":"aio","next":[]}]},{"id":5,"name":"tv","next":[]}]},`    |
| 19 |                  `       "id":55,`                   |                                     `{"id":6,"name":"house","next":[]}]}`                                      |
| 20 |             `       "name":"sneakers",`              |                                                      `]`                                                       |
| 21 |                  `      "parent":2`                  |                                                                                                                |
| 22 |                        `   }`                        |                                                                                                                |
| 23 |                         `]`                          |                                                                                                                |
| 24 |                          6                           |                                                                                                                |
| 25 |         ` [ {"parent":	0,"id":100,  "name":`         |                                                                                                                |
| 26 |                      ` "x"},{`                       |                                                                                                                |
| 27 |                 `"name":"x","id":0}`                 |                                                                                                                |
| 28 |                         `]`                          |                                                                                                                |
| 29 |                                                      |                                                                                                                |
| 30 |                         `[{`                         |                                                                                                                |
| 31 |                     `	"id": 0,`                      |                                                                                                                |
| 32 |                  `	"name": "all",`                   |                                                                                                                |
| 33 |                    `	"next": [{`                     |                                                                                                                |
| 34 |                     `		"id": 1,`                     |                                                                                                                |
| 35 |                `		"name": "clothes",`                |                                                                                                                |
| 36 |                    `		"next": []`                    |                                                                                                                |
| 37 |                       `	}, {`                        |                                                                                                                |
| 38 |                     `		"id": 2,`                     |                                                                                                                |
| 39 |                 `		"name": "shoes",`                 |                                                                                                                |
| 40 |                    `		"next": [{`                    |                                                                                                                |
| 41 |                    `			"id": 55,`                    |                                                                                                                |
| 42 |               `			"name": "sneakers"`                |                                                                                                                |
| 43 |                        `		}]`                        |                                                                                                                |
| 44 |                        `	}]`                         |                                                                                                                |
| 45 |                         `},`                         |                                                                                                                |
| 46 | `{"name":"x","id":0,"next":[{"id":100,"name":"x"}]}` |                                                                                                                |
| 47 |                         `]`                          |                                                                                                                |

>**Примечание**
<br> Любые внешние библиотеки использовать нельзя.
<br>  1) Для работы с **JSON** в языке **C#** можно пользоваться библиотекой **System.Text.Json**. Возможно, вам понадобится увеличить максимальную глубину сериализации/десериализации **JSON** (документация).
<br>  2) Для работы с **JSON** в языке **Go** можно пользоваться библиотекой **encoding/json**.
<br>  3) Для работы с **JSON** в языке Python можно пользоваться библиотекой **json**.

## Task № 6 (3-Покер)
>Колода состоит из 52 карт. Каждая карта обозначается одним из тринадцати значений (2, 3, 4, 5, 6, 7, 8, 9, Ten, Jack, Queen, King, Ace) и одной из четырех мастей (Spades, Clubs, Diamonds, Hearts).
<br> Выдуманная игра 3-Покер происходит следующим образом.
<br> 1) Изначально все **n** игроков получают по две карты из колоды.
<br> 2) После этого на стол выкладывается одна карта из той же колоды.
<br> 3) Выигрывают те игроки, у которых собралась самая старшая комбинация.
<br>Для определения самой старшей комбинации, которая собралась у **i**-го игрока, используются следующие правила:
<br> - если две карты у игрока в руке и карта на столе имеют одинаковое значение, игрок собрал комбинацию 'Сет со значением **x**';
<br> - если из двух карт у игрока в руке и карты на столе можно выбрать две карты с одинаковым значением **x**, игрок собрал комбинацию 'Пара со значением **x**';
<br> - иначе, берется карта с самым старшим значением из двух карт у игрока в руке и карты на столе, тогда игрок собрал комбинацию 'Старшая карта **x**'.
<br> Любой сет старше пары, а любая пара старше комбинации старшая карта. Из одинаковых комбинаций старше та, у которой старше значение. Если одинаковая самая старшая комбинация есть у нескольких игроков, все они объявляются выигрывшими.
<br> Вы — первый игрок. Вам известно, какие карты получил на руки каждый игрок. Определите, какую карту можно выложить на стол, чтобы вы оказались в числе победителей.
<br><br> **Формат входных данных:**
<br> Каждый тест состоит из нескольких наборов входных данных. Первая строка содержит целое число **t(1≤t≤103)** — количество наборов входных данных. Далее следует описание наборов входных данных.
<br> Первая строка каждого набора входных данных содержит целое число **n(2≤n≤25)** — количество игроков.
<br> Следующие **n** строк каждого набора входных данных содержат описания двух карт, разделенных пробелом — карты, которые получил на руки **i**-й игрок.
<br> Описание карты состоит из двух символов, записанных подряд: значения и масти.
<br><br> **Формат выходных данных:**
<br> Для каждого набора входных данных выведите в первой строке количество карт **k**, которые можно выложить на стол для вашей победы. В следующих **k** строках выведите описания этих карт. Выводить описания можно в любом порядке.

### Examples data:
| №  | Input | Output | Input | Output |
|:--:|:-----:|:------:|:-----:|:------:|
| 1  |   4   |   2    |   1   |   30   |
| 2  |   2   |   TD   |   7   |   2S   |
| 3  | TS TC |   TH   | AS AC |   2C   |
| 4  | AD AH |   0    | AD AH |   2D   |
| 5  |   3   |   3    | KS JH |   2H   |
| 6  | 2H 3H |   7S   | 9D 9C |   4S   |
| 7  | 9S 9C |   7C   | 5H 5D |   4C   |
| 8  | 4D QS |   7D   | 3C 3S |   4D   |
| 9  |   3   |   0    | TC TH |   4H   |
| 10 | 4C 7H |        |       |   6S   |
| 11 | 4H 4D |        |       |   6C   |
| 12 | 6S 6H |        |       |   6D   |
| 13 |   3   |        |       |   6H   |
| 14 | 2S 3H |        |       |   7S   |
| 15 | 2C 2D |        |       |   7C   |
| 16 | 3C 3D |        |       |   7D   |
| 17 |       |        |       |   7H   |
| 18 |       |        |       |   8S   |
| 19 |       |        |       |   8C   |
| 20 |       |        |       |   8D   |
| 21 |       |        |       |   8H   |
| 22 |       |        |       |   JS   |
| 23 |       |        |       |   JC   |
| 24 |       |        |       |   JD   |
| 25 |       |        |       |   QS   |
| 26 |       |        |       |   QC   |
| 27 |       |        |       |   QD   |
| 28 |       |        |       |   QH   |
| 29 |       |        |       |   KC   |
| 30 |       |        |       |   KD   |
| 31 |       |        |       |   KH   |

>**Примечание**
<br> **Разберем первый пример.**
<br> В первом наборе входных данных для победы первого игрока можно выложить на стол десятку (T), тогда первый игрок выиграет с комбинацией сет со значением **T**.
<br> Во втором наборе входных данных невозможно добиться победы первого игрока.
<br> В третьем наборе входных данных для победы первого игрока можно выложить на стол семерку (7), тогда первый игрок выиграет с комбинацией пара со значением **7**.
<br> В четвертом наборе входных данных невозможно добиться победы первого игрока.

## Task № 7 (Баны по IP)
> Дан черный список IP адресов. Все IP адреса принадлежат подсети 100.200.0.0/16, то есть имеют вид 100.200.X.Y для некоторых 0≤X,Y<256 .
<br> Вам нужно запретить доступ ко всем адресам из черного списка. Для этого можно создать фильтрующий файл. Каждая запись в файле имеет вид:
<br> - 100.200.0.0/16 — эта запись запрещает доступ к подсети из 65536 адресов, то есть ко всем адресам, которые имеют вид 100.200.X.Y для некоторых 0≤X,Y<256 ;
<br> - 100.200.X.0/24 (0≤X<256) — эта запись запрещает доступ к подсети из 256 адресов, то есть ко всем адресам, которые имеют вид 100.200.X.Y для некоторого 0≤Y<256 ;
<br> - 100.200.X.Y (0≤X,Y<256) — эта запись запрещает доступ к указанному IP адресу.
<br> Из-за технических ограничений в файле не может быть больше, чем k
записей. Вам нужно составить фильтрующий файл так, чтобы доступ ко всем IP адресам из черного списка был запрещен. При этом, количество запрещенных IP адресов не из черного списка должно быть минимально.
<br><br> **Формат входных данных:**
<br> Первая строка содержит два целых числа n и k(1≤n,k≤65536) — размер черного списка IP адресов и максимальное количество записей в фильтрующем файле.
<br> Следующие n cтрок содержат по одному IP адресу из черного списка в формате 100.200.X.Y, 0≤X,Y<256 .
<br><br> **Формат выходных данных:**
<br> В первой строке выведите минимально возможное количество запрещенных IP адресов не из черного списка.
<br> Во второй строке выведите количество использованных записей в файле m(1≤m≤k).
<br> В следующих m строках выведите сами записи.
<br> Если ответов несколько, выведите любой.
 
### Examples data:
| №  |     Input     |     Output     |    Input    |     Output     |    Input    |    Output    |
|:--:|:-------------:|:--------------:|:-----------:|:--------------:|:-----------:|:------------:|
| 1  |      4 2      |      253       |     2 1     |     65534      |    4 100    |      0       | 
| 2  |  100.200.1.1  |       2        | 100.200.3.4 |       1        | 100.200.3.4 |      4       |
| 3  |  100.200.1.2  | 100.200.1.0/24 | 100.200.5.6 | 100.200.0.0/16 | 100.200.5.6 | 100.200.3.4  |
| 4  | 100.200.1.100 | 100.200.100.5  |             |                | 100.200.6.7 | 100.200.5.6  |
| 5  | 100.200.100.5 |                |             |                | 100.200.8.9 | 100.200.6.7  |
| 6  |               |                |             |                |             | 100.200.8.9  |

## Task № 8 (Транспортировка easy)
> Это необычная задача — вам надо написать SQL-запрос. В качестве решения вы должны отослать один запрос к базе данных, который возвращает требуемые данные. Запрос может содержать произвольное количество подзапросов, других конструкций, быть сколь угодно навороченным, но это должен быть один запрос (в нём не должна встречаться точка с запятой для разделения разных запросов).
<br> При проверке вашего решения используется PostgreSQL 15.1. В качестве входных данных вам предоставляется дамп состояния базы данных. Обратите внимание, что время работы вашего решения на тесте включает восстановление состояния базы данных из дампа, но это время значительно меньше ограничения по времени. Вы можете использовать сторонний сервис http://sqlfiddle.com/ как инструмент для запуска запросов.
<br> В этой задаче вам предстоит написать запрос к базе данных перемещений посылок между фулфилментами.
<br> Фулфилмент — это склад, на который и от которого могут доставлять посылки.
<br> Напишите запрос к базе данных, который возвращает информацию про время хранения посылок на фулфилментах:
<br> - идентификатор фулфилмента — соответствующую колонку в выводе следует назвать fulfilment_id;
<br> - название фулфилмента — соответствующую колонку в выводе следует назвать fulfilment_name;
<br> - идентификатор посылки — соответствующую колонку в выводе следует назвать package_id;
<br> - имя посылки — соответствующую колонку в выводе следует назвать package_name;
<br> - время прибытия посылки в фулфилмент — соответствующую колонку в выводе следует назвать time_in;
<br> - время отбытия посылки из фулфилмента — соответствующую колонку в выводе следует назвать time_out;
<br> - время хранения посылки в фулфилменте (т.е. время, прошедшее от прибытия на фулфилмент до отбытия из фулфилмента) — соответствующую колонку в выводе следует назвать storage_time.
<br>  Строки в выводе сортируйте в первую очередь по невозрастанию storage_time, затем по возрастанию time_in, затем по возрастанию fulfilment_id, затем по возрастанию package_id.
Внимательно ознакомьтесь с примерами вывода. Ваш запрос должен иметь в точности такой же вывод, как на примерах. Схема базы данных содержит четыре таблицы:
<br>  - transportations — перемещения посылок между фулфилментами (описываются полями: id (идентификатор транспортировки), package_id (идентификатор посылки), source_id (идентификатор фулфилмента, из которого отправляется посылка), destination_id (идентификатор фулфилмента, на который приходит посылка), departure_time (время отправки посылки из фулфилмента source_id), arrival_time (время прибытия посылки в фулфилмент destination_id));
<br>  -  packages — посылки (описываются двумя полями: id и name),
<br>  -  fulfilments — фулфилменты (описываются двумя полями: id и name).
<br>   Таким образом, packages и transportations находятся в отношении «один ко многим», fulfilments и transportations находятся в отношении «многие к одному».
<br>   **Известно, что любая посылка находилась в любом фулфилменте не более одного раза.**
<br>   Изучите входные данные примера, чтобы подробно ознакомиться со схемой базы данных. Диаграмма выше иллюстрирует схему базы данных.
<br><br> **Формат входных данных:**
<br> Входными данными в этой задаче является дамп базы данных. Вам он может быть полезен для ознакомления с состоянием базы данных для конкретного теста. В качестве решения вы должны отправить один SQL-запрос.
<br><br> **Формат выходных данных:**
<br> Внимательно ознакомьтесь с примерами вывода. Ваш запрос должен иметь в точности такой же вывод, как на примерах.

### Examples data:
<table>
    <thead>
        <tr>
            <th> № </th>
            <th> Input </th>
        </tr>
    </thead>
<tbody>
        <tr>
            <td rowspan=4 align="center">1</td>
            <td rowspan=4> 
create table packages <br>
( <br>
    id   bigint primary key, <br>
    name text not null <br>
);<br>

create table fulfilments <br>
( <br>
id   bigint primary key, <br>
name text not null <br>
); <br>

create table transportations <br>
( <br>
 id             bigint primary key, <br>
 package_id     bigint    not null, <br>
 source_id      bigint    not null, <br>
 destination_id bigint    not null, <br>
 departure_time timestamp not null, <br>
 arrival_time   timestamp not null, <br>
 constraint fk_transportations_package_id foreign key (package_id) references packages (id), <br>
 constraint fk_transportations_source_id foreign key (source_id) references fulfilments (id), <br>
 constraint fk_transportations_destination_id foreign key (destination_id) references fulfilments (id) <br>
);

insert into packages <br>
values (1, 'Package slow'), <br>
(2, 'Package fast'), <br>
(3, 'Package strange'); <br>

insert into fulfilments <br>
values (1, 'Moscow'), <br>
(2, 'Spb'), <br>
(3, 'Almaty'), <br>
(4, 'Novosibirsk'), <br>
(5, 'Vladivostok'); <br>

insert into transportations <br>
values (1, 1, 1, 3, '2023-01-01 12:00:00', '2023-01-13 12:00:00'),<br>
(2, 1, 3, 5, '2023-01-15 12:00:00', '2023-01-31 12:00:00'), <br>
(3, 1, 5, 2, '2023-02-27 12:00:00', '2023-03-14 12:00:00'), <br>
(4, 1, 2, 4, '2023-03-15 12:00:00', '2023-03-28 12:00:00'), <br>
(5, 2, 1, 2, '2023-02-15 12:00:00', '2023-02-15 18:00:00'), <br>
(6, 3, 2, 3, '2023-04-02 12:00:00', '2023-04-05 12:00:00'), <br>
(7, 3, 3, 5, '2023-04-07 12:00:00', '2023-04-28 12:00:00');` 
</td>
        </tr>
    </tbody>
</table>

## Output 

| № | fulfilment_id | fulfilment_name | package_id |  package_name   |       time_in       |      time_out       | storage_time |
|:-:|:-------------:|:---------------:|:----------:|:---------------:|:-------------------:|:-------------------:|:------------:|
| 1 |       5       |   Vladivostok   |     1      |  Package slow   | 2023-01-31 12:00:00 | 2023-02-27 12:00:00 |   27 days    |
| 2 |       3       |     Almaty      |     1      |  Package slow   | 2023-01-13 12:00:00 | 2023-01-15 12:00:00 |    2 days    |
| 3 |       3       |     Almaty      |     3      | Package strange | 2023-04-05 12:00:00 | 2023-04-07 12:00:00 |    2 days    |
| 4 |       2       |       Spb       |     1      |  Package slow   | 2023-03-14 12:00:00 | 2023-03-15 12:00:00 |    1 day     |
***(4 rows)***

>**Примечание**
<br> **Разберем пример из условия.**
<br> Посылка 1 (Package slow) с 2023-01-13 12:00:00 до 2023-01-15 12:00:00 находилась в фулфилменте 3; с 2023-01-31 12:00:00 до 2023-02-27 12:00:00 находилась в фулфилменте 5; с 2023-03-14 12:00:00 до 2023-03-15 12:00:00 находилась в фулфилменте 2.
<br> Посылка 3 (Package strange) с 2023-04-05 12:00:00 до 2023-04-07 12:00:00 находилась в фулфилменте 3.

## Task № 9 (Транспортировка hard)
>Это необычная задача — вам надо написать SQL-запрос. В качестве решения вы должны отослать один запрос к базе данных, который возвращает требуемые данные. Запрос может содержать произвольное количество подзапросов, других конструкций, быть сколь угодно навороченным, но это должен быть один запрос (в нём не должна встречаться точка с запятой для разделения разных запросов).
<br> При проверке вашего решения используется PostgreSQL 15.1. В качестве входных данных вам предоставляется дамп состояния базы данных. Обратите внимание, что время работы вашего решения на тесте включает восстановление состояния базы данных из дампа, но это время значительно меньше ограничения по времени. Вы можете использовать сторонний сервис http://sqlfiddle.com/ как инструмент для запуска запросов.
<br> В этой задаче вам предстоит написать запрос к базе данных перемещений посылок между фулфилментами.
<br> Фулфилмент — это склад, на который и от которого могут доставлять посылки.
<br> Напишите запрос к базе данных, который возвращает информацию про время хранения посылок на фулфилментах:
<br> - идентификатор фулфилмента — соответствующую колонку в выводе следует назвать fulfilment_id;
<br> - название фулфилмента — соответствующую колонку в выводе следует назвать fulfilment_name;
<br> - идентификатор посылки — соответствующую колонку в выводе следует назвать package_id;
<br> - имя посылки — соответствующую колонку в выводе следует назвать package_name;
<br> - время прибытия посылки в фулфилмент — соответствующую колонку в выводе следует назвать time_in;
<br> - время отбытия посылки из фулфилмента — соответствующую колонку в выводе следует назвать time_out;
<br> - время хранения посылки в фулфилменте (т.е. время, прошедшее от прибытия на фулфилмент до отбытия от фулфилмента) — соответствующую колонку в выводе следует назвать storage_time.
<br> Строки в выводе сортируйте в первую очередь по невозрастанию storage_time, затем по возрастанию time_in, затем по возрастанию fulfilment_id, затем по возрастанию package_id.
<br> Внимательно ознакомьтесь с примерами вывода. Ваш запрос должен иметь в точности такой же вывод, как на примерах.
<br> Схема базы данных содержит четыре таблицы:
<br>  - transportations — перемещения посылок между фулфилментами (описываются полями: id (идентификатор транспортировки), package_id (идентификатор посылки), source_id (идентификатор фулфилмента, из которого отправляется посылка), destination_id (идентификатор фулфилмента, в который приходит посылка), departure_time (время отправки посылки из фулфилмента source_id), arrival_time (время прибытия посылки в фулфилмент destination_id));
<br>  - packages — посылки (описываются двумя полями: id и name),
<br>  - fulfilments — фулфилменты (описываются двумя полями: id и name).
<br>  Таким образом, packages и transportations находятся в отношении «один ко многим», fulfilments и transportations находятся в отношении «многие к одному».
<br>  **Любая посылка может быть перемещена в один и тот же фулфилмент несколько раз. В том числе, посылка может быть перемещена из фулфилмента в него же (source_id равен destination_id).**
<br>  Изучите входные данные примера, чтобы подробно ознакомиться со схемой базы данных. Диаграмма выше иллюстрирует схему базы данных.
<br><br> **Формат входных данных:**
<br> Входными данными в этой задаче является дамп базы данных. Вам он может быть полезен для ознакомления с состоянием базы данных для конкретного теста. В качестве решения вы должны отправить один SQL-запрос.
<br><br> **Формат выходных данных:**
<br> Внимательно ознакомьтесь с примерами вывода. Ваш запрос должен иметь в точности такой же вывод, как на примерах.

<table>
    <thead>
        <tr>
            <th> № </th>
            <th> Input </th>
        </tr>
    </thead>
    <tbody>
        <tr>
    <td rowspan=4 align="center"> 1 </td>
            <td rowspan=4>
create table packages <br>
( <br>
    id   bigint primary key, <br>
    name text not null <br>
); <br>

create table fulfilments <br>
( <br>
id   bigint primary key, <br>
name text not null <br>
); <br>

create table transportations <br>
( <br>
id             bigint primary key, <br>
package_id     bigint    not null, <br>
source_id      bigint    not null, <br>
destination_id bigint    not null, <br>
departure_time timestamp not null, <br>
arrival_time   timestamp not null, <br>
constraint fk_transportations_package_id foreign key (package_id) references packages (id), <br>
constraint fk_transportations_source_id foreign key (source_id) references fulfilments (id), <br>
constraint fk_transportations_destination_id foreign key (destination_id) references fulfilments (id) <br>
); <br>

insert into packages <br>
values (1, 'Package slow'), <br>
(2, 'Package fast'), <br>
(3, 'Package strange'); <br>

insert into fulfilments <br>
values (1, 'Moscow'), <br>
(2, 'Spb'), <br>
(3, 'Almaty'), <br>
(4, 'Novosibirsk'), <br>
(5, 'Vladivostok'); <br>

insert into transportations <br>
values (1, 1, 1, 3, '2023-01-01 12:00:00', '2023-01-13 12:00:00'), <br>
(2, 1, 3, 3, '2023-01-15 12:00:00', '2023-01-31 12:00:00'), <br>
(3, 1, 3, 5, '2023-02-27 12:00:00', '2023-03-14 12:00:00'), <br>
(4, 1, 5, 5, '2023-03-15 12:00:00', '2023-03-28 12:00:00'), <br>
(5, 2, 1, 2, '2023-02-15 12:00:00', '2023-02-15 18:00:00'), <br>
(6, 3, 2, 3, '2023-04-02 12:00:00', '2023-04-05 12:00:00'), <br>
(7, 3, 3, 5, '2023-04-07 12:00:00', '2023-04-28 12:00:00'); <br>
</td>
            
        </tr>
    </tbody>
</table>

## Output

| № | fulfilment_id | fulfilment_name | package_id |  package_name   |       time_in       |      time_out       | storage_time |
|:-:|:-------------:|:---------------:|:----------:|:---------------:|:-------------------:|:-------------------:|:------------:|
| 1 |       3       |     Almaty      |     1      |  Package slow   | 2023-01-31 12:00:00 | 2023-02-27 12:00:00 |   27 days    |
| 2 |       3       |     Almaty      |     1      |  Package slow   | 2023-01-13 12:00:00 | 2023-01-15 12:00:00 |    2 days    |
| 3 |       3       |     Almaty      |     3      | Package strange | 2023-04-05 12:00:00 | 2023-04-07 12:00:00 |    2 days    |
| 4 |       5       |   Vladivostok   |     1      |  Package slow   | 2023-03-14 12:00:00 | 2023-03-15 12:00:00 |    1 day     |
***(4 rows)***

>**Примечание**
<br> **Разберем пример из условия.**
<br>Посылка 1 (Package slow) с 2023-01-13 12:00:00 до 2023-01-15 12:00:00 находилась в фулфилменте 3 первый раз; с 2023-01-31 12:00:00 до 2023-02-27 12:00:00 находилась в фулфилменте 3 второй раз; с 2023-03-14 12:00:00 до 2023-03-15 12:00:00 находилась в фулфилменте 2.
<br>Посылка 3 (Package strange) с 2023-04-05 12:00:00 до 2023-04-07 12:00:00 находилась в фулфилменте 3.

---

## Author
<h3>Kahramon Hadjibaev <br> <br>2023 </h3>